timelog =timelog_create(MaxSize);
timelog_log(timelog, sss);	// Multithread safe
timelog_dump(file)


struct Item{
	unsigned long 	ulTime;
	char			acMsg[100];

	Item()
	{
		memset(this, 0, sizeof(*this));
	}
};

struct Threadpara{
	boost::circular_buffer<Item> queue;
	int thread;
};

static boost::thread_specific_ptr<Threadpara> StreamThreadSpecificPtr;

struct TimeLog{
	int maxSz;
	std::vector<Threadpara*> para;
};

void* timelog_create(int maxsz)
{
	TimeLog *tm=new TimeLog;
	tm->maxSz=maxsz;
	return tm;
}

void timelog_log(timelog, sss)
{
	Threadpara * stream = NULL;
    stream = StreamThreadSpecificPtr.get();
    if (NULL == stream) {
        stream = new Threadpara(timelog->maxsz, getTid());
        StreamThreadSpecificPtr.reset(stream);
		
		lock(timelog->add(stream));
    }
	else
	{
		assert(GetTid9)==stream->thread;
	}
	stream->queue.enqueue(sss, GetTime());
}

void timelog_dump(timelog)
{
	para
}
