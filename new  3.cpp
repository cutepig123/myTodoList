IMG_WORD ITF_SPI_GenPinHoleMask(stZFine, stCRes, pstLrnPara->uwSubsampleInterval, uwPinHoleKrnlSz, pstLrnRcd)

struct	ITF_SPI_PINHOLE_LRN_PAR{
	IMG_UWORD	uwSubsampleInterval;	///<	Pinhole mask is subsampled to reduce record size
	IMG_UWORD	uwPinHoleKrnlSz;		///<	Pinhole mask is generated by erosion of valid data mask
	IMG_REAL	rZDiffThres;			///<	Pixels with Z level out of norminal Z + rZDiffThres are masked as invalid
};

IMG_WORD DSP_MeanWithMask(IMG_RBUF const *prbZ, IMG_UBBUF const *pubbM, IMG_REAL *prMean)
{
	assert( prbZ->size.x ==pubbM->size.x);
	
	IppiSize roiSize;
	roiSize.width = prbZ->size.x;
	roiSize.height = prbZ->size.y;
	
	Ipp64f dMean;
	IppStatus ippSts =ippiMean_32f_C1MR( prbZ->ptr, prbZ->linestep *sizeof(IMG_REAL), 
		pubbM->ptr, pubbM->linestep *sizeof(IMG_UBYTE), roiSize, &dMean);
	if( ippSts!=ippStsNoErr)
	{
		assert(0);
		return ERR_FAIL;
	}
	*prMean =dMean;
	return OK;
}

IMG_WORD DSP_Thres_L(IMG_RBUF const *prbZ, IMG_REAL rThres, IMG_UBBUF *pubbM)
{
	IMG_WORD wStatus =OK;
	assert( prbZ->size.x ==pubbM->size.x);
	
	MEM_PushAllHeapStatus();
	
	IMG_REAL rbM;
	wStatus = MEM_AllocBufAtBank( prbZ->size,SYS_BANK1_32,(IMG_VVBUF*)&(rbM));
	DS_SET_STATUS( wStatus, &wStatus);
	if( DSP_ERROR_STATUS(wStatus)) goto EXIT;
	
	IppiSize roiSize;
	roiSize.width = prbZ->size.x;
	roiSize.height = prbZ->size.y;
	
	IppStatus ippSts =ippiThreshold_LT_32f_C1R( prbZ->ptr, prbZ->linestep *sizeof(IMG_REAL),
		rbM.ptr, rbM.linestep *sizeof(IMG_REAL), roiSize, rThres);
	if( ippSts!=ippStsNoErr)
	{
		assert(0);
		wStatus= ERR_FAIL;
		goto Exit;
	}
	
	ippSts = ippiConvert_32f8u_C1R( rbM.ptr, rbM.linestep *sizeof(IMG_REAL), 
		pubbM->ptr, pubbM->linestep *sizeof(IMG_UBYTE), roiSize, ippRndNear);
	if( ippSts!=ippStsNoErr)
	{
		assert(0);
		wStatus= ERR_FAIL;
		goto Exit;
	}
Exit:
	MEM_PopAllHeapStatus();
	return wStatus;
}

IMG_WORD ITF_SPI_GenPinHoleMask(A3D_INS_PROFS					const	&stZFine,
								IMG_UBBUF						const	*pubbBaseBoardMask,
								ITF_SPI_PINHOLE_LRN_PAR			const	*pstLrnPara,
								SMT_SPI_PADS_LRN_RCD					*pstLrnRcd,
								IMG_UBYTE								ubDebug,
								IMG_CHAR						const	*pcLogPath
								)
{
	IMG_WORD	wStatus =OK;
	IMG_SIZE	szSubsampledHeightImg;
	
	MEM_PushAllHeapStatus();
	szSubsampledHeightImg.x = (IMG_UWORD)ceilf(  (IMG_REAL)stZFine.arbZ[0].size.x 
											   / (IMG_REAL)( pstLrnPara->uwSubsampleInterval+1)   );
	szSubsampledHeightImg.y = (IMG_UWORD)ceilf(  (IMG_REAL)stZFine.arbZ[0].size.y 
											   / (IMG_REAL)( pstLrnPara->uwSubsampleInterval+1)   );

											   
	wStatus = DSP_AllocBuf( &szSubsampledHeightImg, UB_PIXEL_SZ, (IMG_VVBUF*)&pstLrnRcd->ubbPinHoleMsk );
	if( wStatus != OK )
	{
		SYS_Assert(0);
		goto EXIT;
	}
	DSP_FillBuffer_ub_MMX(0, &(pstLrnRcd->ubbPinHoleMsk),&coZero, &szSubsampledHeightImg);
	
	IMG_UBBUF	ubbSubsamleMsk;

	wStatus = MEM_AllocBufAtBank( &(pstLrnRcd->ubbPinHoleMsk.size),SYS_BANK1_8,(IMG_VVBUF*)&(ubbSubsamleMsk));
	DS_SET_STATUS( wStatus, &wStatus);
	if( DSP_ERROR_STATUS(wStatus)) goto EXIT;

	// Pinhole mask
	{
		// -> ubbSubsamleMsk
		assert(stZFine.ubbNumAccess->size.x /(pstLrnPara->uwSubsampleInterval+1) ==pstLrnRcd->ubbPinHoleMsk.size.x);
		
		wStatus = DSP_SubSample_ub( stZFine.ubbNumAccess,
									&coZero,
									pstLrnPara->uwSubsampleInterval+1,
									pstLrnPara->uwSubsampleInterval+1,
									&(ubbSubsamleMsk),
									&coZero,
									&(ubbSubsamleMsk.size)
								);
		DS_SET_STATUS( wStatus, &wStatus);
		if( DSP_ERROR_STATUS(wStatus)) goto EXIT;

		// ubbSubsamleMsk -Ero-> ubbPinHoleMsk
		IMG_UBBUF	ubbKrnl;
		IMG_SIZE szKrnl;
		szKrnl.x =szKrnl.y =pstLrnPara->uwPinHoleKrnlSz/(pstLrnPara->uwSubsampleInterval+1);
		wStatus = MEM_AllocBufAtBank( &(szKrnl),SYS_BANK1_8,(IMG_VVBUF*)&(ubbKrnl));
		DS_SET_STATUS( wStatus, &wStatus);
		if( DSP_ERROR_STATUS(wStatus)) goto EXIT;
		
		std::fill(ubbKrnl.ptr, ubbKrnl.ptr +pstLrnPara->uwPinHoleKrnlSz*pstLrnPara->uwPinHoleKrnlSz, 1);
		DSP_ErodeBin_gen(&ubbSubsamleMsk, &coZero, &ubbKrnl, &pstLrnRcd->ubbPinHoleMsk,
			&coZero, &pstLrnRcd->ubbPinHoleMsk.size);	


	}
	
	// Z filtering
	{
		IMG_REAL 	rNominalZ;
		IMG_UBBUF 	ubbThresM;	///<	Mask after thresholding, the invalid data may be 0 r 1, but we donot care
		
		wStatus = MEM_AllocBufAtBank( &(stZFine.arbZ[0].size),SYS_BANK1_8,(IMG_VVBUF*)&(ubbThresM));
		DS_SET_STATUS( wStatus, &wStatus);
		if( DSP_ERROR_STATUS(wStatus)) goto EXIT;
		
		DSP_MeanWithMask(&stZFine.arbZ[0], pubbBaseBoardMask, &rNominalZ);
		DSP_Thres_L(&stZFine.arbZ[0], rNominalZ +pstLrnPara->rZDiffThres, &ubbThresM);
		
		wStatus = DSP_SubSample_ub( ubbThresM,&coZero,pstLrnPara->uwSubsampleInterval+1,pstLrnPara->uwSubsampleInterval+1,
										&(ubbSubsamleMsk),&coZero,&(ubbSubsamleMsk.size));
		DS_SET_STATUS( wStatus, &wStatus);
		if( DSP_ERROR_STATUS(wStatus)) goto EXIT;
		
		assert( ubbSubsamleMsk.size.x == pstLrnRcd->ubbPinHoleMsk.size.x);
		
		if(ubDebug)
		{
			IMG_CHAR acLogFile[MAX_PATH];
			_sprintf(acLogFile, MAX_PATH, "%s\\PinHoleZMask.bmp",pcLogPath);
			FILE_SaveImage(&ubbSubsamleMsk, NULL, NULL, (IMG_UBYTE*)acLogFile);
		}
		
		DSP_And_ububub( &ubbSubsamleMsk, &coZero, &pstLrnRcd->ubbPinHoleMsk, &coZero, &pstLrnRcd->ubbPinHoleMsk, &coZero, &ubbSubsamleMsk.size);
	}
EXIT:
	MEM_PopAllHeapStatus();
	return wStatus;
}
	